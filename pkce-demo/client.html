<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <title>PKCE Demo – Boutique sécurisée</title>

  <style>
    body { font-family: sans-serif; margin: 30px; }
    input, button { margin: 6px 0; padding: 6px 10px; }
    pre { background:#f4f4f4; padding:10px; white-space:pre-wrap; }
    section { margin-top: 25px; padding-top: 10px; border-top: 1px solid #ddd; }
    h2 { margin-bottom: 8px; }
    .row { display: flex; gap: 30px; align-items: flex-start; }
    .col { flex: 1; min-width: 280px; }
    ul { padding-left: 20px; }
    li { margin-bottom: 4px; }
    .small { font-size: 0.85em; color:#444; }
  </style>
</head>

<body>

  <h1>PKCE Demo – Petite boutique sécurisée</h1>

  <!-- ================== LOGIN PKCE ================== -->

  <section>
    <h2>1) Connexion (PKCE)</h2>
    <form id="loginForm">
      <label>Username</label><br />
      <input id="username" required />

      <br />
      <label>Password</label><br />
      <input id="password" type="password" required />

      <br />
      <button type="submit">Login / Obtenir un token</button>
    </form>

    <p class="small">
      Après connexion, le token est utilisé pour appeler le Resource Server (produits, commandes, historique…).
    </p>

    <h3>Résumé PKCE</h3>
    <pre id="output">Rien pour l'instant.</pre>

    <h3>Timeline (étapes invisibles)</h3>
    <pre id="timeline"></pre>
  </section>

  <!-- ================== BOUTIQUE ================== -->

  <section>
    <h2>2) Boutique (Resource Server)</h2>

    <div class="row">
      <div class="col">
        <h3>Produits disponibles</h3>
        <button id="btnLoadProducts" disabled>Charger les produits</button>
        <ul id="productsList"></ul>
      </div>

      <div class="col">
        <h3>Passer une commande</h3>
        <p class="small">
          Pour la démo : on commande un article en choisissant son ID et la quantité.
        </p>
        <label>ID du produit</label><br />
        <input id="orderProductId" type="number" min="1" value="1" />
        <br />
        <label>Quantité</label><br />
        <input id="orderQty" type="number" min="1" value="1" />
        <br />
        <button id="btnOrder" disabled>Passer la commande</button>

        <h4>Historique de mes commandes</h4>
        <button id="btnLoadOrders" disabled>Actualiser l'historique</button>
        <ul id="ordersList"></ul>
      </div>
    </div>
  </section>

  <!-- ================== JOURNAL DE SÉCURITÉ ================== -->

  <section>
    <h2>3) Journal de sécurité (ce qui se passe côté sécu)</h2>
    <p class="small">
      Tout ce que fait ton client (login, profil, commandes…) est journalisé côté Resource Server.
      On affiche ici le contenu de <code>http://localhost:7000/security-log</code>.
    </p>
    <button id="btnLoadSecurity" disabled>Rafraîchir le journal de sécurité</button>
    <pre id="securityLog">Rien pour l'instant.</pre>
  </section>

  <!-- ================== SCRIPT ================== -->

  <script>
    // --------- outils PKCE déjà présents ---------

    function logStep(msg, obj = null) {                                               // Log visuel des étapes
      const t = document.getElementById("timeline");                                   // Zone timeline
      t.textContent += "\n\n- " + msg;                                                // Ajoute un message
      if (obj) t.textContent += "\n" + JSON.stringify(obj, null, 2);                  // Ajoute un JSON si besoin
    }

    function base64urlencode(arrayBuffer) {                                           // Buffer -> Base64 URL safe
      const bytes = new Uint8Array(arrayBuffer);
      let binary = "";
      bytes.forEach(b => binary += String.fromCharCode(b));
      return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }

    function randomString(length = 64) {                                              // String random sécurisée
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      return base64urlencode(array);
    }

    async function sha256(plain) {                                                    // SHA-256 côté navigateur
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return await crypto.subtle.digest("SHA-256", data);
    }

    async function generatePKCE() {                                                   // Génère verifier + challenge
      const code_verifier = randomString(64);
      const hashed = await sha256(code_verifier);
      const code_challenge = base64urlencode(hashed);
      return { code_verifier, code_challenge };
    }

    // --------- variable globale pour le token ---------

    let ACCESS_TOKEN = null;

    function enableButtonsAfterLogin() {
      const hasToken = !!ACCESS_TOKEN;
      document.getElementById("btnLoadProducts").disabled = !hasToken;
      document.getElementById("btnOrder").disabled = !hasToken;
      document.getElementById("btnLoadOrders").disabled = !hasToken;
      document.getElementById("btnLoadSecurity").disabled = !hasToken;
    }

    // --------- Login / PKCE flow ---------

    document.getElementById("loginForm").addEventListener("submit", async (e) => {
      e.preventDefault();

      const username = document.getElementById("username").value;
      const password = document.getElementById("password").value;

      logStep("Utilisateur clique Login");

      const { code_verifier, code_challenge } = await generatePKCE();               // PKCE
      sessionStorage.setItem("code_verifier", code_verifier);

      logStep("PKCE généré", { code_verifier, code_challenge });

      // 1) Appel /authorize avec le challenge -> reçoit authorization_code
      let authorizeResponse = null;

      try {
        logStep("Envoi code_challenge vers /authorize");

        const res = await fetch("http://localhost:5000/authorize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code_challenge })
        });

        authorizeResponse = await res.json();
      } catch (err) {
        authorizeResponse = { error: "fetch_failed", details: String(err) };
      }

      logStep("Réponse /authorize reçue", authorizeResponse);

      const authorization_code = authorizeResponse.authorization_code;
      const stored_verifier = sessionStorage.getItem("code_verifier");

      // 2) Appel /token avec authorization_code + verifier -> reçoit access_token
      let tokenResponse = null;

      try {
        logStep("Envoi authorization_code + code_verifier vers /token");

        const resToken = await fetch("http://localhost:5000/token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            authorization_code,
            code_verifier: stored_verifier
          })
        });

        tokenResponse = await resToken.json();
      } catch (err) {
        tokenResponse = { error: "fetch_failed", details: String(err) };
      }

      logStep("Réponse /token reçue", tokenResponse);

      // On récupère le token
      ACCESS_TOKEN = tokenResponse.access_token || null;
      enableButtonsAfterLogin();

      // 3) Appel Resource Server /profile avec Bearer token
      let profileResponse = null;

      try {
        logStep("Appel /profile avec Bearer token");

        const profRes = await fetch("http://localhost:7000/profile", {
          method: "GET",
          headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
        });

        profileResponse = await profRes.json();
      } catch (err) {
        profileResponse = { error: "fetch_failed", details: String(err) };
      }

      logStep("Réponse /profile reçue", profileResponse);

      // Affichage final dans le bloc "Résumé PKCE"
      document.getElementById("output").textContent =
        "username: " + username + "\n" +
        "password: " + "*".repeat(password.length) + "\n\n" +
        "code_verifier:\n" + code_verifier + "\n\n" +
        "code_challenge:\n" + code_challenge + "\n\n" +
        "Réponse /authorize:\n" + JSON.stringify(authorizeResponse, null, 2) + "\n\n" +
        "Réponse /token:\n" + JSON.stringify(tokenResponse, null, 2) + "\n\n" +
        "Réponse /profile:\n" + JSON.stringify(profileResponse, null, 2);

      // On peut aussi charger automatiquement les produits + logs après login
      if (ACCESS_TOKEN) {
        await loadProducts();
        await loadOrders();
        await loadSecurityLog();
      }
    });

    // --------- Fonctions pour parler au Resource Server ---------

    async function loadProducts() {
      if (!ACCESS_TOKEN) return;

      const ul = document.getElementById("productsList");
      ul.innerHTML = "Chargement...";
      try {
        const res = await fetch("http://localhost:7000/products", {
          headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
        });
        const products = await res.json();
        ul.innerHTML = "";
        products.forEach(p => {
          const li = document.createElement("li");
          li.textContent = `#${p.id} – ${p.name} (${p.price} €) – ${p.description || ""}`;
          ul.appendChild(li);
        });
        if (products.length === 0) {
          ul.innerHTML = "<li>Aucun produit pour l'instant.</li>";
        }
      } catch (err) {
        ul.innerHTML = "<li>Erreur de chargement des produits : " + err + "</li>";
      }
    }

    async function createOrder() {
      if (!ACCESS_TOKEN) return;

      const productId = parseInt(document.getElementById("orderProductId").value, 10);
      const qty = parseInt(document.getElementById("orderQty").value, 10);

      const body = {
        items: [{ product_id: productId, quantity: qty }]
      };

      try {
        const res = await fetch("http://localhost:7000/orders", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + ACCESS_TOKEN
          },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        alert("Commande créée, id = " + data.order_id);
        await loadOrders();
        await loadSecurityLog();
      } catch (err) {
        alert("Erreur lors de la commande : " + err);
      }
    }

    async function loadOrders() {
      if (!ACCESS_TOKEN) return;

      const ul = document.getElementById("ordersList");
      ul.innerHTML = "Chargement...";
      try {
        const res = await fetch("http://localhost:7000/orders", {
          headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
        });
        const orders = await res.json();
        ul.innerHTML = "";
        orders.forEach(o => {
          const li = document.createElement("li");
          li.textContent = `Commande #${o.id} – ${o.created_at} – Total: ${o.total} €`;
          ul.appendChild(li);
        });
        if (orders.length === 0) {
          ul.innerHTML = "<li>Aucune commande pour l'instant.</li>";
        }
      } catch (err) {
        ul.innerHTML = "<li>Erreur de chargement des commandes : " + err + "</li>";
      }
    }

    async function loadSecurityLog() {
      if (!ACCESS_TOKEN) return;

      const pre = document.getElementById("securityLog");
      pre.textContent = "Chargement...";
      try {
        const res = await fetch("http://localhost:7000/security-log", {
          headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
        });
        const log = await res.json();
        pre.textContent = JSON.stringify(log, null, 2);
      } catch (err) {
        pre.textContent = "Erreur de chargement du journal de sécurité : " + err;
      }
    }

    // --------- Binding des boutons ---------

    document.getElementById("btnLoadProducts").addEventListener("click", loadProducts);
    document.getElementById("btnOrder").addEventListener("click", createOrder);
    document.getElementById("btnLoadOrders").addEventListener("click", loadOrders);
    document.getElementById("btnLoadSecurity").addEventListener("click", loadSecurityLog);

  </script>

</body>
</html>
