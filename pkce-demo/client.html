<!DOCTYPE html>
<html lang="fr">

<head>                                                                                 <!-- Partie non visible -->
  <meta charset="UTF-8" />
  <title>Client Page (PKCE)</title>                                                   <!-- Titre onglet -->

  <style>
    body { font-family: sans-serif; margin: 30px; }                                   /* Style simple */
    input { display:block; margin:8px 0; padding:6px; width:250px; }                  /* Inputs */
    pre { background:#f4f4f4; padding:10px; white-space:pre-wrap; }                  /* Zones logs */
  </style>
</head>

<body>
  <h1>Page Client (simule Google)</h1>                                                <!-- Titre -->

  <form id="loginForm">                                                               <!-- Form login -->
    <label>Username</label>
    <input id="username" required />
    <label>Password</label>
    <input id="password" type="password" required />
    <button type="submit">Login</button>
  </form>

  <h2>R√©sultat PKCE</h2>
  <pre id="output">Rien pour l'instant.</pre>

  <h2>Timeline (√©tapes invisibles)</h2>
  <pre id="timeline"></pre>

  <script>
    function logStep(msg, obj=null) {                                                 // Fonction de log visible
      const t = document.getElementById("timeline");                                  // Zone timeline
      t.textContent += "\n\n‚ñ∂ " + msg;                                                // Ajoute un titre d'√©tape
      if (obj) t.textContent += "\n" + JSON.stringify(obj, null, 2);                  // Ajoute un JSON si dispo
    }

    function base64urlencode(arrayBuffer) {                                           // Buffer -> Base64 URL safe
      const bytes = new Uint8Array(arrayBuffer);
      let binary = "";
      bytes.forEach(b => binary += String.fromCharCode(b));
      return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }

    function randomString(length = 64) {                                              // G√©n√®re string random s√©curis√©e
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      return base64urlencode(array);
    }

    async function sha256(plain) {                                                    // SHA-256 d'une string
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return await crypto.subtle.digest("SHA-256", data);
    }

    async function generatePKCE() {                                                   // G√©n√®re verifier + challenge
      const code_verifier = randomString(64);
      const hashed = await sha256(code_verifier);
      const code_challenge = base64urlencode(hashed);
      return { code_verifier, code_challenge };
    }

    document.getElementById("loginForm").addEventListener("submit", async (e) => {
      e.preventDefault();                                                             // Stop reload

      const username = document.getElementById("username").value;                     // Username
      const password = document.getElementById("password").value;                     // Password

      logStep("Utilisateur clique Login");                                            // Timeline

      const { code_verifier, code_challenge } = await generatePKCE();                 // PKCE
      sessionStorage.setItem("code_verifier", code_verifier);                         // Stock verifier

      logStep("PKCE g√©n√©r√© ‚úÖ", { code_verifier, code_challenge });                   // Timeline PKCE

      let authzResponse = null;                                                       // R√©ponse AuthZ

      try {
        logStep("Envoi du challenge √† /authorize");                                   // Timeline avant fetch

        const res = await fetch("http://localhost:5000/authorize", {                  // Appel AuthZ
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code_challenge })
        });

        authzResponse = await res.json();                                             // Parse JSON

      } catch (err) {
        authzResponse = { error: "fetch_failed", details: String(err) };              // Erreur
      }

      logStep("R√©ponse /authorize re√ßue", authzResponse);                             // Timeline AuthZ

      // üî• NOUVEAU : on lit le r√©sum√© auto-register renvoy√© par AuthZ
      logStep("AuthZ a auto-enregistr√© le token au Resource Server",                  // Timeline action invisible
              authzResponse.resource_register);

      const access_token = authzResponse.access_token;                                // Token

      let profileResponse = null;                                                     // R√©ponse Resource

      try {
        logStep("Appel /profile avec Bearer token");                                  // Timeline avant /profile

        const profRes = await fetch("http://localhost:7000/profile", {                // ResourceServer
          method: "GET",
          headers: { "Authorization": "Bearer " + access_token }
        });

        profileResponse = await profRes.json();                                       // Parse JSON
      } catch (err) {
        profileResponse = { error: "fetch_failed", details: String(err) };            // Erreur
      }

      logStep("R√©ponse /profile (Resource Server)", profileResponse);                 // Timeline Resource

      document.getElementById("output").textContent =
        "username: " + username + "\n" +
        "password: " + "*".repeat(password.length) + "\n\n" +
        "code_verifier:\n" + code_verifier + "\n\n" +
        "code_challenge:\n" + code_challenge + "\n\n" +
        "R√©ponse AuthZServer:\n" + JSON.stringify(authzResponse, null, 2) + "\n\n" +
        "R√©ponse ResourceServer:\n" + JSON.stringify(profileResponse, null, 2);
    });
  </script>
</body>
</html>
